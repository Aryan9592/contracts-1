{
  "address": "0x84789AD8a8992AA3d65e5f609658BbED4abAac17",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IChromaticMarketFactory",
          "name": "_factory",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_automate",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "opsProxyFactory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "OnlyAccessableByMarket",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "automate",
      "outputs": [
        {
          "internalType": "contract IAutomate",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "cancelClaimPositionTask",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "cancelLiquidationTask",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "market",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "claimPosition",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "createClaimPositionTask",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "createLiquidationTask",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dedicatedMsgSender",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "market",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "liquidate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_market",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "resolveClaimPosition",
      "outputs": [
        {
          "internalType": "bool",
          "name": "canExec",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "execPayload",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_market",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "resolveLiquidation",
      "outputs": [
        {
          "internalType": "bool",
          "name": "canExec",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "execPayload",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb7336ef6c718f18e7d628db0585ad502dd99140e23233e6a6a8f27f7123f2cce",
  "receipt": {
    "to": null,
    "from": "0x3bD0496CA35b200FCc21CAc644208F7b11838EF6",
    "contractAddress": "0x84789AD8a8992AA3d65e5f609658BbED4abAac17",
    "transactionIndex": 1,
    "gasUsed": "980376",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7a0d9a6598ebac7901da29fee28f740259656037027759b0db67b114915f2d59",
    "transactionHash": "0xb7336ef6c718f18e7d628db0585ad502dd99140e23233e6a6a8f27f7123f2cce",
    "logs": [],
    "blockNumber": 27425109,
    "cumulativeGasUsed": "980376",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x20F98C4dDf4c04928eb2302F341dc7eE08d358be",
    "0xa5f9b728ecEB9A1F6FCC89dcc2eFd810bA4Dec41",
    "0x0000000000000000000000000000000000000000"
  ],
  "numDeployments": 1,
  "solcInputHash": "af00bff573074f858ccf429eb1fa6af5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IChromaticMarketFactory\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_automate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"opsProxyFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyAccessableByMarket\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"automate\",\"outputs\":[{\"internalType\":\"contract IAutomate\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"cancelClaimPositionTask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"cancelLiquidationTask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"claimPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"createClaimPositionTask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"createLiquidationTask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dedicatedMsgSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"resolveClaimPosition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"resolveLiquidation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"A contract that handles the liquidation and claiming of positions in Chromatic markets.      It extends the Liquidator and AutomateReady contracts and implements the IChromaticLiquidator interface.\",\"errors\":{\"OnlyAccessableByMarket()\":[{\"details\":\"Throws an error indicating that the function can only be accessed by a registered market.\"}]},\"kind\":\"dev\",\"methods\":{\"cancelClaimPositionTask(uint256)\":{\"details\":\"Can only be called by a registered market.\",\"params\":{\"positionId\":\"The ID of the position for which to cancel the claim position task.\"}},\"cancelLiquidationTask(uint256)\":{\"details\":\"Can only be called by a registered market.\",\"params\":{\"positionId\":\"The ID of the position for which to cancel the liquidation task.\"}},\"claimPosition(address,uint256)\":{\"details\":\"Can only be called by the dedicated message sender.\",\"params\":{\"market\":\"The address of the market contract.\",\"positionId\":\"The ID of the position to be claimed.\"}},\"constructor\":{\"details\":\"Constructor function.\",\"params\":{\"_automate\":\"The address of the Gelato Automate contract.\",\"_factory\":\"The address of the Chromatic Market Factory contract.\",\"opsProxyFactory\":\"The address of the Ops Proxy Factory contract.\"}},\"createClaimPositionTask(uint256)\":{\"details\":\"Can only be called by a registered market.\",\"params\":{\"positionId\":\"The ID of the position to be claimed.\"}},\"createLiquidationTask(uint256)\":{\"details\":\"Can only be called by a registered market.\",\"params\":{\"positionId\":\"The ID of the position to be liquidated.\"}},\"liquidate(address,uint256)\":{\"details\":\"Can only be called by the dedicated message sender.\",\"params\":{\"market\":\"The address of the market contract.\",\"positionId\":\"The ID of the position to be liquidated.\"}},\"resolveClaimPosition(address,uint256)\":{\"details\":\"This function is called by the Gelato automation system.\",\"params\":{\"market\":\"The address of the market contract.\",\"positionId\":\"The ID of the position to be claimed.\"},\"returns\":{\"canExec\":\"Whether the claim can be executed.\",\"execPayload\":\"The encoded function call to execute the claim.\"}},\"resolveLiquidation(address,uint256)\":{\"details\":\"This function is called by the Gelato automation system.\",\"params\":{\"market\":\"The address of the market contract.\",\"positionId\":\"The ID of the position to be liquidated.\"},\"returns\":{\"canExec\":\"Whether the liquidation can be executed.\",\"execPayload\":\"The encoded function call to execute the liquidation.\"}}},\"title\":\"ChromaticLiquidator\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"cancelClaimPositionTask(uint256)\":{\"notice\":\"Cancels a claim position task for a given position.\"},\"cancelLiquidationTask(uint256)\":{\"notice\":\"Cancels a liquidation task for a given position.\"},\"claimPosition(address,uint256)\":{\"notice\":\"Claims a position in a market.\"},\"createClaimPositionTask(uint256)\":{\"notice\":\"Creates a claim position task for a given position.\"},\"createLiquidationTask(uint256)\":{\"notice\":\"Creates a liquidation task for a given position.\"},\"liquidate(address,uint256)\":{\"notice\":\"Liquidates a position in a market.\"},\"resolveClaimPosition(address,uint256)\":{\"notice\":\"Resolves the claim of a position.\"},\"resolveLiquidation(address,uint256)\":{\"notice\":\"Resolves the liquidation of a position.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/ChromaticLiquidator.sol\":\"ChromaticLiquidator\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[\":@chromatic-protocol/contracts/=contracts/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":forge-std/=lib/forge-std/src/\"]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9b72f93be69ca894d8492c244259615c4a742afc8d63720dbc8bb81087d9b238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/core/ChromaticLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IChromaticMarketFactory} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticMarketFactory.sol\\\";\\nimport {IChromaticLiquidator} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticLiquidator.sol\\\";\\nimport {Liquidator} from \\\"@chromatic-protocol/contracts/core/base/Liquidator.sol\\\";\\nimport {AutomateReady} from \\\"@chromatic-protocol/contracts/core/base/gelato/AutomateReady.sol\\\";\\nimport {IAutomate} from \\\"@chromatic-protocol/contracts/core/base/gelato/Types.sol\\\";\\n\\n/**\\n * @title ChromaticLiquidator\\n * @dev A contract that handles the liquidation and claiming of positions in Chromatic markets.\\n *      It extends the Liquidator and AutomateReady contracts and implements the IChromaticLiquidator interface.\\n */\\ncontract ChromaticLiquidator is Liquidator, AutomateReady {\\n    /**\\n     * @dev Constructor function.\\n     * @param _factory The address of the Chromatic Market Factory contract.\\n     * @param _automate The address of the Gelato Automate contract.\\n     * @param opsProxyFactory The address of the Ops Proxy Factory contract.\\n     */\\n    constructor(\\n        IChromaticMarketFactory _factory,\\n        address _automate,\\n        address opsProxyFactory\\n    ) Liquidator(_factory) AutomateReady(_automate, address(this), opsProxyFactory) {}\\n\\n    /**\\n     * @inheritdoc Liquidator\\n     */\\n    function getAutomate() internal view override returns (IAutomate) {\\n        return automate;\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticLiquidator\\n     * @dev Can only be called by the dedicated message sender.\\n     */\\n    function liquidate(\\n        address market,\\n        uint256 positionId\\n    ) external override onlyDedicatedMsgSender {\\n        // feeToken is the native token because ETH is set as a fee token when creating task\\n        // TODO: need test in goerli\\n        (uint256 fee, ) = _getFeeDetails();\\n        _liquidate(market, positionId, fee);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticLiquidator\\n     * @dev Can only be called by the dedicated message sender.\\n     */\\n    function claimPosition(\\n        address market,\\n        uint256 positionId\\n    ) external override onlyDedicatedMsgSender {\\n        // feeToken is the native token because ETH is set as a fee token when creating task\\n        (uint256 fee, ) = _getFeeDetails();\\n        _claimPosition(market, positionId, fee);\\n    }\\n}\\n\",\"keccak256\":\"0x787d3eb4e0d4d6594c5c76793095efb8ad4da16e5fc127403299b416cd7b3058\",\"license\":\"BUSL-1.1\"},\"contracts/core/base/Liquidator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IChromaticLiquidator} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticLiquidator.sol\\\";\\nimport {IChromaticMarketFactory} from \\\"@chromatic-protocol/contracts/core/interfaces/IChromaticMarketFactory.sol\\\";\\nimport {IMarketLiquidate} from \\\"@chromatic-protocol/contracts/core/interfaces/market/IMarketLiquidate.sol\\\";\\nimport {IAutomate, Module, ModuleData} from \\\"@chromatic-protocol/contracts/core/base/gelato/Types.sol\\\";\\n\\n/**\\n * @title Liquidator\\n * @dev An abstract contract for liquidation functionality in the Chromatic protocol.\\n */\\nabstract contract Liquidator is IChromaticLiquidator {\\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    uint256 private constant LIQUIDATION_INTERVAL = 30 seconds;\\n    uint256 private constant CLAIM_INTERVAL = 10 minutes;\\n\\n    IChromaticMarketFactory factory;\\n\\n    mapping(address => mapping(uint256 => bytes32)) private _liquidationTaskIds;\\n    mapping(address => mapping(uint256 => bytes32)) private _claimPositionTaskIds;\\n\\n    /**\\n     * @dev Modifier to check if the calling contract is a registered market.\\n     */\\n    modifier onlyMarket() {\\n        if (!factory.isRegisteredMarket(msg.sender)) revert OnlyAccessableByMarket();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the Liquidator contract.\\n     * @param _factory The address of the ChromaticMarketFactory contract.\\n     */\\n    constructor(IChromaticMarketFactory _factory) {\\n        factory = _factory;\\n    }\\n\\n    /**\\n     * @dev Retrieves the IAutomate contract instance.\\n     * @return IAutomate The IAutomate contract instance.\\n     */\\n    function getAutomate() internal view virtual returns (IAutomate);\\n\\n    /**\\n     * @inheritdoc IChromaticLiquidator\\n     * @dev Can only be called by a registered market.\\n     */\\n    function createLiquidationTask(uint256 positionId) external override onlyMarket {\\n        _createTask(_liquidationTaskIds, positionId, this.resolveLiquidation, LIQUIDATION_INTERVAL);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticLiquidator\\n     * @dev Can only be called by a registered market.\\n     */\\n    function cancelLiquidationTask(uint256 positionId) external override onlyMarket {\\n        _cancelTask(_liquidationTaskIds, positionId);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticLiquidator\\n     */\\n    function resolveLiquidation(\\n        address _market,\\n        uint256 positionId\\n    ) external view override returns (bool canExec, bytes memory execPayload) {\\n        if (IMarketLiquidate(_market).checkLiquidation(positionId)) {\\n            return (true, abi.encodeCall(this.liquidate, (_market, positionId)));\\n        }\\n\\n        return (false, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @dev Internal function to perform the liquidation of a position.\\n     * @param _market The address of the market contract.\\n     * @param positionId The ID of the position to be liquidated.\\n     * @param fee The fee to be paid for the liquidation.\\n     */\\n    function _liquidate(address _market, uint256 positionId, uint256 fee) internal {\\n        IMarketLiquidate market = IMarketLiquidate(_market);\\n        market.liquidate(positionId, getAutomate().gelato(), fee);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticLiquidator\\n     * @dev Can only be called by a registered market.\\n     */\\n    function createClaimPositionTask(uint256 positionId) external override onlyMarket {\\n        _createTask(_claimPositionTaskIds, positionId, this.resolveClaimPosition, CLAIM_INTERVAL);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticLiquidator\\n     * @dev Can only be called by a registered market.\\n     */\\n    function cancelClaimPositionTask(uint256 positionId) external override onlyMarket {\\n        _cancelTask(_claimPositionTaskIds, positionId);\\n    }\\n\\n    /**\\n     * @inheritdoc IChromaticLiquidator\\n     */\\n    function resolveClaimPosition(\\n        address _market,\\n        uint256 positionId\\n    ) external view override returns (bool canExec, bytes memory execPayload) {\\n        if (IMarketLiquidate(_market).checkClaimPosition(positionId)) {\\n            return (true, abi.encodeCall(this.claimPosition, (_market, positionId)));\\n        }\\n\\n        return (false, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to perform the claim of a position.\\n     * @param _market The address of the market contract.\\n     * @param positionId The ID of the position to be claimed.\\n     * @param fee The fee to be paid for the claim.\\n     */\\n    function _claimPosition(address _market, uint256 positionId, uint256 fee) internal {\\n        IMarketLiquidate market = IMarketLiquidate(_market);\\n        market.claimPosition(positionId, getAutomate().gelato(), fee);\\n    }\\n\\n    /**\\n     * @dev Internal function to create a Gelato task for liquidation or claim position.\\n     * @param registry The mapping to store task IDs.\\n     * @param positionId The ID of the position.\\n     * @param resolve The resolve function to be called by the Gelato automation system.\\n     * @param interval The interval between task executions.\\n     */\\n    function _createTask(\\n        mapping(address => mapping(uint256 => bytes32)) storage registry,\\n        uint256 positionId,\\n        function(address, uint256) external view returns (bool, bytes memory) resolve,\\n        uint256 interval\\n    ) internal {\\n        address market = msg.sender;\\n        if (registry[market][positionId] != bytes32(0)) {\\n            return;\\n        }\\n\\n        ModuleData memory moduleData = ModuleData({modules: new Module[](3), args: new bytes[](3)});\\n\\n        moduleData.modules[0] = Module.RESOLVER;\\n        moduleData.modules[1] = Module.TIME;\\n        moduleData.modules[2] = Module.PROXY;\\n        moduleData.args[0] = abi.encode(\\n            address(this),\\n            abi.encodeCall(resolve, (market, positionId))\\n        );\\n        moduleData.args[1] = abi.encode(uint128(block.timestamp), uint128(interval));\\n        moduleData.args[2] = bytes(\\\"\\\");\\n\\n        registry[market][positionId] = getAutomate().createTask(\\n            address(this),\\n            abi.encode(this.liquidate.selector),\\n            moduleData,\\n            ETH\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function to cancel a Gelato task.\\n     * @param registry The mapping storing task IDs.\\n     * @param positionId The ID of the position.\\n     */\\n    function _cancelTask(\\n        mapping(address => mapping(uint256 => bytes32)) storage registry,\\n        uint256 positionId\\n    ) internal {\\n        address market = msg.sender;\\n        bytes32 taskId = registry[market][positionId];\\n        if (taskId != bytes32(0)) {\\n            getAutomate().cancelTask(taskId);\\n            delete registry[market][positionId];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9479e294289929c6b80f37169f3512e37b57b445d63f69b2e1495e2f26b4ef07\",\"license\":\"BUSL-1.1\"},\"contracts/core/base/gelato/AutomateReady.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IAutomate, IOpsProxyFactory, ITaskTreasuryUpgradable, ModuleData} from \\\"@chromatic-protocol/contracts/core/base/gelato/Types.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @dev Inherit this contract to allow your smart contract to\\n * - Make synchronous fee payments.\\n * - Have call restrictions for functions to be automated.\\n */\\n// solhint-disable private-vars-leading-underscore\\nabstract contract AutomateReady {\\n    IAutomate public immutable automate;\\n    address public immutable dedicatedMsgSender;\\n    address private immutable _gelato;\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant OPS_PROXY_FACTORY = 0xC815dB16D4be6ddf2685C201937905aBf338F5D7;\\n\\n    /**\\n     * @dev\\n     * Only tasks created by _taskCreator defined in constructor can call\\n     * the functions with this modifier.\\n     */\\n    modifier onlyDedicatedMsgSender() {\\n        require(msg.sender == dedicatedMsgSender, Errors.ONLY_DEDICATED_MSG_SENDER_CAN_ACCESS);\\n        _;\\n    }\\n\\n    /**\\n     * @dev\\n     * _taskCreator is the address which will create tasks for this contract.\\n     */\\n    constructor(address _automate, address _taskCreator, address opsProxyFactory) {\\n        automate = IAutomate(_automate);\\n        _gelato = IAutomate(_automate).gelato();\\n        if (opsProxyFactory == address(0)) opsProxyFactory = OPS_PROXY_FACTORY;\\n        (dedicatedMsgSender, ) = IOpsProxyFactory(opsProxyFactory).getProxyOf(_taskCreator);\\n    }\\n\\n    /**\\n     * @dev\\n     * Transfers fee to gelato for synchronous fee payments.\\n     *\\n     * _fee & _feeToken should be queried from IAutomate.getFeeDetails()\\n     */\\n    function _transfer(uint256 _fee, address _feeToken) internal {\\n        if (_feeToken == ETH) {\\n            (bool success, ) = _gelato.call{value: _fee}(\\\"\\\");\\n            require(success, Errors.ETH_TRANSFER_FAILED);\\n        } else {\\n            SafeERC20.safeTransfer(IERC20(_feeToken), _gelato, _fee);\\n        }\\n    }\\n\\n    function _getFeeDetails() internal view returns (uint256 fee, address feeToken) {\\n        (fee, feeToken) = automate.getFeeDetails();\\n    }\\n}\\n\",\"keccak256\":\"0xff9b7150a2ab796e660206edfb8f5c8a3fe2e8990e9bdfccd680e7b9aa0eab75\",\"license\":\"UNLICENSED\"},\"contracts/core/base/gelato/Types.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0 <0.9.0;\\n\\nenum Module {\\n    RESOLVER,\\n    TIME,\\n    PROXY,\\n    SINGLE_EXEC\\n}\\n\\nstruct ModuleData {\\n    Module[] modules;\\n    bytes[] args;\\n}\\n\\ninterface IAutomate {\\n    function createTask(\\n        address execAddress,\\n        bytes calldata execDataOrSelector,\\n        ModuleData calldata moduleData,\\n        address feeToken\\n    ) external returns (bytes32 taskId);\\n\\n    function cancelTask(bytes32 taskId) external;\\n\\n    function getFeeDetails() external view returns (uint256, address);\\n\\n    function gelato() external view returns (address payable);\\n\\n    function taskTreasury() external view returns (ITaskTreasuryUpgradable);\\n}\\n\\ninterface ITaskTreasuryUpgradable {\\n    function depositFunds(address receiver, address token, uint256 amount) external payable;\\n\\n    function withdrawFunds(address payable receiver, address token, uint256 amount) external;\\n}\\n\\ninterface IOpsProxyFactory {\\n    function getProxyOf(address account) external view returns (address, bool);\\n}\\n\",\"keccak256\":\"0x119933c31bfd5801eed35cd7f24a56670ce1dba9ab72caac8471cfd82cd67ec3\",\"license\":\"UNLICENSED\"},\"contracts/core/interfaces/IChromaticLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IChromaticLiquidator\\n * @dev Interface for the Chromatic Liquidator contract.\\n */\\ninterface IChromaticLiquidator {\\n    /**\\n     * @dev Throws an error indicating that the function can only be accessed by a registered market.\\n     */\\n    error OnlyAccessableByMarket();\\n\\n    /**\\n     * @notice Creates a liquidation task for a given position.\\n     * @param positionId The ID of the position to be liquidated.\\n     */\\n    function createLiquidationTask(uint256 positionId) external;\\n\\n    /**\\n     * @notice Cancels a liquidation task for a given position.\\n     * @param positionId The ID of the position for which to cancel the liquidation task.\\n     */\\n    function cancelLiquidationTask(uint256 positionId) external;\\n\\n    /**\\n     * @notice Resolves the liquidation of a position.\\n     * @dev This function is called by the Gelato automation system.\\n     * @param market The address of the market contract.\\n     * @param positionId The ID of the position to be liquidated.\\n     * @return canExec Whether the liquidation can be executed.\\n     * @return execPayload The encoded function call to execute the liquidation.\\n     */\\n    function resolveLiquidation(\\n        address market,\\n        uint256 positionId\\n    ) external view returns (bool canExec, bytes memory execPayload);\\n\\n    /**\\n     * @notice Liquidates a position in a market.\\n     * @param market The address of the market contract.\\n     * @param positionId The ID of the position to be liquidated.\\n     */\\n    function liquidate(address market, uint256 positionId) external;\\n\\n    /**\\n     * @notice Creates a claim position task for a given position.\\n     * @param positionId The ID of the position to be claimed.\\n     */\\n    function createClaimPositionTask(uint256 positionId) external;\\n\\n    /**\\n     * @notice Cancels a claim position task for a given position.\\n     * @param positionId The ID of the position for which to cancel the claim position task.\\n     */\\n    function cancelClaimPositionTask(uint256 positionId) external;\\n\\n    /**\\n     * @notice Resolves the claim of a position.\\n     * @dev This function is called by the Gelato automation system.\\n     * @param market The address of the market contract.\\n     * @param positionId The ID of the position to be claimed.\\n     * @return canExec Whether the claim can be executed.\\n     * @return execPayload The encoded function call to execute the claim.\\n     */\\n    function resolveClaimPosition(\\n        address market,\\n        uint256 positionId\\n    ) external view returns (bool canExec, bytes memory execPayload);\\n\\n    /**\\n     * @notice Claims a position in a market.\\n     * @param market The address of the market contract.\\n     * @param positionId The ID of the position to be claimed.\\n     */\\n    function claimPosition(address market, uint256 positionId) external;\\n}\\n\",\"keccak256\":\"0xc66f3a457caf3920ccb4449cbc3ab4291eaade94f3a9a2927cf9d91db044a5dd\",\"license\":\"MIT\"},\"contracts/core/interfaces/IChromaticMarketFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IInterestCalculator} from \\\"@chromatic-protocol/contracts/core/interfaces/IInterestCalculator.sol\\\";\\nimport {IMarketDeployer} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/IMarketDeployer.sol\\\";\\nimport {ISettlementTokenRegistry} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/ISettlementTokenRegistry.sol\\\";\\nimport {IOracleProviderRegistry} from \\\"@chromatic-protocol/contracts/core/interfaces/factory/IOracleProviderRegistry.sol\\\";\\n\\n/**\\n * @title IChromaticMarketFactory\\n * @dev Interface for the Chromatic Market Factory contract.\\n */\\ninterface IChromaticMarketFactory is\\n    IMarketDeployer,\\n    IOracleProviderRegistry,\\n    ISettlementTokenRegistry,\\n    IInterestCalculator\\n{\\n    /**\\n     * @notice Emitted when the DAO address is updated.\\n     * @param dao The new DAO address.\\n     */\\n    event UpdateDao(address indexed dao);\\n\\n    /**\\n     * @notice Emitted when the DAO treasury address is updated.\\n     * @param treasury The new DAO treasury address.\\n     */\\n    event UpdateTreasury(address indexed treasury);\\n\\n    /**\\n     * @notice Emitted when the liquidator address is set.\\n     * @param liquidator The liquidator address.\\n     */\\n    event SetLiquidator(address indexed liquidator);\\n\\n    /**\\n     * @notice Emitted when the vault address is set.\\n     * @param vault The vault address.\\n     */\\n    event SetVault(address indexed vault);\\n\\n    /**\\n     * @notice Emitted when the keeper fee payer address is set.\\n     * @param keeperFeePayer The keeper fee payer address.\\n     */\\n    event SetKeeperFeePayer(address indexed keeperFeePayer);\\n\\n    /**\\n     * @notice Emitted when a market is created.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param settlementToken The address of the settlement token.\\n     * @param market The address of the created market.\\n     */\\n    event MarketCreated(\\n        address indexed oracleProvider,\\n        address indexed settlementToken,\\n        address indexed market\\n    );\\n\\n    /**\\n     * @notice Returns the address of the DAO.\\n     * @return The address of the DAO.\\n     */\\n    function dao() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the DAO treasury.\\n     * @return The address of the DAO treasury.\\n     */\\n    function treasury() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the liquidator.\\n     * @return The address of the liquidator.\\n     */\\n    function liquidator() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the vault.\\n     * @return The address of the vault.\\n     */\\n    function vault() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the keeper fee payer.\\n     * @return The address of the keeper fee payer.\\n     */\\n    function keeperFeePayer() external view returns (address);\\n\\n    /**\\n     * @notice Updates the DAO address.\\n     * @param dao The new DAO address.\\n     */\\n    function updateDao(address dao) external;\\n\\n    /**\\n     * @notice Updates the DAO treasury address.\\n     * @param treasury The new DAO treasury address.\\n     */\\n    function updateTreasury(address treasury) external;\\n\\n    /**\\n     * @notice Sets the liquidator address.\\n     * @param liquidator The liquidator address.\\n     */\\n    function setLiquidator(address liquidator) external;\\n\\n    /**\\n     * @notice Sets the vault address.\\n     * @param vault The vault address.\\n     */\\n    function setVault(address vault) external;\\n\\n    /**\\n     * @notice Sets the keeper fee payer address.\\n     * @param keeperFeePayer The keeper fee payer address.\\n     */\\n    function setKeeperFeePayer(address keeperFeePayer) external;\\n\\n    /**\\n     * @notice Returns an array of all market addresses.\\n     * @return markets An array of all market addresses.\\n     */\\n    function getMarkets() external view returns (address[] memory markets);\\n\\n    /**\\n     * @notice Returns an array of market addresses associated with a settlement token.\\n     * @param settlementToken The address of the settlement token.\\n     * @return An array of market addresses.\\n     */\\n    function getMarketsBySettlmentToken(\\n        address settlementToken\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the address of a market associated with an oracle provider and settlement token.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param settlementToken The address of the settlement token.\\n     * @return The address of the market.\\n     */\\n    function getMarket(\\n        address oracleProvider,\\n        address settlementToken\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Creates a new market associated with an oracle provider and settlement token.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param settlementToken The address of the settlement token.\\n     */\\n    function createMarket(address oracleProvider, address settlementToken) external;\\n\\n    /**\\n     * @notice Checks if a market is registered.\\n     * @param market The address of the market.\\n     * @return True if the market is registered, false otherwise.\\n     */\\n    function isRegisteredMarket(address market) external view returns (bool);\\n\\n    /**\\n     * @notice Creates a Maker earning distribution task for a token.\\n     * @param token The address of the token.\\n     */\\n    function createMakerEarningDistributionTask(address token) external;\\n\\n    /**\\n     * @notice Cancels a Maker earning distribution task for a token.\\n     * @param token The address of the token.\\n     */\\n    function cancelMakerEarningDistributionTask(address token) external;\\n\\n    /**\\n     * @notice Creates a market earning distribution task for a market.\\n     * @param market The address of the market.\\n     */\\n    function createMarketEarningDistributionTask(address market) external;\\n\\n    /**\\n     * @notice Cancels a market earning distribution task for a market.\\n     * @param market The address of the market.\\n     */\\n    function cancelMarketEarningDistributionTask(address market) external;\\n}\\n\",\"keccak256\":\"0x0112f74860cabe86e383932c524b99d92288602b637b14c00edbcd5188bc84bf\",\"license\":\"MIT\"},\"contracts/core/interfaces/IInterestCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IInterestCalculator\\n * @dev Interface for an interest calculator contract.\\n */\\ninterface IInterestCalculator {\\n    /**\\n     * @notice Calculates the interest accrued for a given token and amount within a specified time range.\\n     * @param token The address of the token.\\n     * @param amount The amount of the token.\\n     * @param from The starting timestamp (inclusive) of the time range.\\n     * @param to The ending timestamp (exclusive) of the time range.\\n     * @return The accrued interest for the specified token and amount within the given time range.\\n     */\\n    function calculateInterest(\\n        address token,\\n        uint256 amount,\\n        uint256 from, // timestamp (inclusive)\\n        uint256 to // timestamp (exclusive)\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xf70b44ce6eb1422abed056169dc5db83ddbb2ee34d7751192f00e6cb3dc1ccbe\",\"license\":\"MIT\"},\"contracts/core/interfaces/factory/IMarketDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title An interface for a contract that is capable of deploying Chromatic markets\\n * @notice A contract that constructs a market must implement this to pass arguments to the market\\n * @dev This is used to avoid having constructor arguments in the market contract, which results in the init code hash\\n * of the market being constant allowing the CREATE2 address of the market to be cheaply computed on-chain\\n */\\ninterface IMarketDeployer {\\n    /**\\n     * @notice Get the parameters to be used in constructing the market, set transiently during market creation.\\n     * @dev Called by the market constructor to fetch the parameters of the market\\n     * Returns underlyingAsset The underlying asset of the market\\n     * Returns settlementToken The settlement token of the market\\n     * Returns vPoolCapacity Capacity of virtual future pool\\n     * Returns vPoolA Amplification coefficient of virtual future pool, precise value\\n     */\\n    function parameters() external view returns (address oracleProvider, address settlementToken);\\n}\\n\",\"keccak256\":\"0x6ce7c90b2b1a8ff9b721644a33ab4585d84fdacf789af3ea6169f49dc033fd77\",\"license\":\"MIT\"},\"contracts/core/interfaces/factory/IOracleProviderRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IOracleProviderRegistry\\n * @dev Interface for the Oracle Provider Registry contract.\\n */\\ninterface IOracleProviderRegistry {\\n    /**\\n     * @dev Emitted when a new oracle provider is registered.\\n     * @param oracleProvider The address of the registered oracle provider.\\n     */\\n    event OracleProviderRegistered(address indexed oracleProvider);\\n\\n    /**\\n     * @dev Emitted when an oracle provider is unregistered.\\n     * @param oracleProvider The address of the unregistered oracle provider.\\n     */\\n    event OracleProviderUnregistered(address indexed oracleProvider);\\n\\n    /**\\n     * @dev Emitted when the level of an oracle provider is set.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param level The new level set for the oracle provider.\\n     */\\n    event SetOracleProviderLevel(address indexed oracleProvider, uint8 indexed level);\\n\\n    /**\\n     * @notice Registers an oracle provider.\\n     * @param oracleProvider The address of the oracle provider to register.\\n     */\\n    function registerOracleProvider(address oracleProvider) external;\\n\\n    /**\\n     * @notice Unregisters an oracle provider.\\n     * @param oracleProvider The address of the oracle provider to unregister.\\n     */\\n    function unregisterOracleProvider(address oracleProvider) external;\\n\\n    /**\\n     * @notice Gets the registered oracle providers.\\n     * @return An array of registered oracle provider addresses.\\n     */\\n    function registeredOracleProviders() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Checks if an oracle provider is registered.\\n     * @param oracleProvider The address of the oracle provider to check.\\n     * @return A boolean indicating if the oracle provider is registered.\\n     */\\n    function isRegisteredOracleProvider(address oracleProvider) external view returns (bool);\\n\\n    /**\\n     * @notice Retrieves the level of an oracle provider in the registry.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @return The level of the oracle provider.\\n     */\\n    function getOracleProviderLevel(address oracleProvider) external view returns (uint8);\\n\\n    /**\\n     * @notice Sets the level of an oracle provider in the registry.\\n     * @dev The level must be either 0 or 1, and the max leverage must be x10 for level 0 or x20 for level 1.\\n     * @param oracleProvider The address of the oracle provider.\\n     * @param level The new level to be set for the oracle provider.\\n     */\\n    function setOracleProviderLevel(address oracleProvider, uint8 level) external;\\n}\\n\",\"keccak256\":\"0x7b2789456b7c609e8acf1414389502b009f7a0504e8f1986383ceff51953754d\",\"license\":\"MIT\"},\"contracts/core/interfaces/factory/ISettlementTokenRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {InterestRate} from \\\"@chromatic-protocol/contracts/core/libraries/InterestRate.sol\\\";\\n\\n/**\\n * @title ISettlementTokenRegistry\\n * @dev Interface for the Settlement Token Registry contract.\\n */\\ninterface ISettlementTokenRegistry {\\n    /**\\n     * @dev Emitted when a new settlement token is registered.\\n     * @param token The address of the registered settlement token.\\n     * @param minimumMargin The minimum margin for the markets using this settlement token.\\n     * @param interestRate The interest rate for the settlement token.\\n     * @param flashLoanFeeRate The flash loan fee rate for the settlement token.\\n     * @param earningDistributionThreshold The earning distribution threshold for the settlement token.\\n     * @param uniswapFeeTier The Uniswap fee tier for the settlement token.\\n     */\\n    event SettlementTokenRegistered(\\n        address indexed token,\\n        uint256 indexed minimumMargin,\\n        uint256 indexed interestRate,\\n        uint256 flashLoanFeeRate,\\n        uint256 earningDistributionThreshold,\\n        uint24 uniswapFeeTier\\n    );\\n\\n    /**\\n     * @dev Emitted when the minimum margin for a settlement token is set.\\n     * @param token The address of the settlement token.\\n     * @param minimumMargin The new minimum margin for the settlement token.\\n     */\\n    event SetMinimumMargin(address indexed token, uint256 indexed minimumMargin);\\n\\n    /**\\n     * @dev Emitted when the flash loan fee rate for a settlement token is set.\\n     * @param token The address of the settlement token.\\n     * @param flashLoanFeeRate The new flash loan fee rate for the settlement token.\\n     */\\n    event SetFlashLoanFeeRate(address indexed token, uint256 indexed flashLoanFeeRate);\\n\\n    /**\\n     * @dev Emitted when the earning distribution threshold for a settlement token is set.\\n     * @param token The address of the settlement token.\\n     * @param earningDistributionThreshold The new earning distribution threshold for the settlement token.\\n     */\\n    event SetEarningDistributionThreshold(\\n        address indexed token,\\n        uint256 indexed earningDistributionThreshold\\n    );\\n\\n    /**\\n     * @dev Emitted when the Uniswap fee tier for a settlement token is set.\\n     * @param token The address of the settlement token.\\n     * @param uniswapFeeTier The new Uniswap fee tier for the settlement token.\\n     */\\n    event SetUniswapFeeTier(address indexed token, uint24 indexed uniswapFeeTier);\\n\\n    /**\\n     * @dev Emitted when an interest rate record is appended for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param annualRateBPS The annual interest rate in basis points (BPS).\\n     * @param beginTimestamp The timestamp when the interest rate record begins.\\n     */\\n    event InterestRateRecordAppended(\\n        address indexed token,\\n        uint256 indexed annualRateBPS,\\n        uint256 indexed beginTimestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when the last interest rate record is removed for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param annualRateBPS The annual interest rate in basis points (BPS).\\n     * @param beginTimestamp The timestamp when the interest rate record begins.\\n     */\\n    event LastInterestRateRecordRemoved(\\n        address indexed token,\\n        uint256 indexed annualRateBPS,\\n        uint256 indexed beginTimestamp\\n    );\\n\\n    /**\\n     * @notice Registers a new settlement token.\\n     * @param token The address of the settlement token to register.\\n     * @param minimumMargin The minimum margin for the settlement token.\\n     * @param interestRate The interest rate for the settlement token.\\n     * @param flashLoanFeeRate The flash loan fee rate for the settlement token.\\n     * @param earningDistributionThreshold The earning distribution threshold for the settlement token.\\n     * @param uniswapFeeTier The Uniswap fee tier for the settlement token.\\n     */\\n    function registerSettlementToken(\\n        address token,\\n        uint256 minimumMargin,\\n        uint256 interestRate,\\n        uint256 flashLoanFeeRate,\\n        uint256 earningDistributionThreshold,\\n        uint24 uniswapFeeTier\\n    ) external;\\n\\n    /**\\n     * @notice Gets the list of registered settlement tokens.\\n     * @return An array of addresses representing the registered settlement tokens.\\n     */\\n    function registeredSettlementTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Checks if a settlement token is registered.\\n     * @param token The address of the settlement token to check.\\n     * @return True if the settlement token is registered, false otherwise.\\n     */\\n    function isRegisteredSettlementToken(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Gets the minimum margin for a settlement token.\\n     * @dev The minimumMargin is used as the minimum value for the taker margin of a position\\n     *      or as the minimum value for the maker margin of each bin.\\n     * @param token The address of the settlement token.\\n     * @return The minimum margin for the settlement token.\\n     */\\n    function getMinimumMargin(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the minimum margin for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param minimumMargin The new minimum margin for the settlement token.\\n     */\\n    function setMinimumMargin(address token, uint256 minimumMargin) external;\\n\\n    /**\\n     * @notice Gets the flash loan fee rate for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return The flash loan fee rate for the settlement token.\\n     */\\n    function getFlashLoanFeeRate(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the flash loan fee rate for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param flashLoanFeeRate The new flash loan fee rate for the settlement token.\\n     */\\n    function setFlashLoanFeeRate(address token, uint256 flashLoanFeeRate) external;\\n\\n    /**\\n     * @notice Gets the earning distribution threshold for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return The earning distribution threshold for the settlement token.\\n     */\\n    function getEarningDistributionThreshold(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the earning distribution threshold for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param earningDistributionThreshold The new earning distribution threshold for the settlement token.\\n     */\\n    function setEarningDistributionThreshold(\\n        address token,\\n        uint256 earningDistributionThreshold\\n    ) external;\\n\\n    /**\\n     * @notice Gets the Uniswap fee tier for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return The Uniswap fee tier for the settlement token.\\n     */\\n    function getUniswapFeeTier(address token) external view returns (uint24);\\n\\n    /**\\n     * @notice Sets the Uniswap fee tier for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param uniswapFeeTier The new Uniswap fee tier for the settlement token.\\n     */\\n    function setUniswapFeeTier(address token, uint24 uniswapFeeTier) external;\\n\\n    /**\\n     * @notice Appends an interest rate record for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @param annualRateBPS The annual interest rate in basis points (BPS).\\n     * @param beginTimestamp The timestamp when the interest rate record begins.\\n     */\\n    function appendInterestRateRecord(\\n        address token,\\n        uint256 annualRateBPS,\\n        uint256 beginTimestamp\\n    ) external;\\n\\n    /**\\n     * @notice Removes the last interest rate record for a settlement token.\\n     * @param token The address of the settlement token.\\n     */\\n    function removeLastInterestRateRecord(address token) external;\\n\\n    /**\\n     * @notice Gets the current interest rate for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return The current interest rate for the settlement token.\\n     */\\n    function currentInterestRate(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets all the interest rate records for a settlement token.\\n     * @param token The address of the settlement token.\\n     * @return An array of interest rate records for the settlement token.\\n     */\\n    function getInterestRateRecords(\\n        address token\\n    ) external view returns (InterestRate.Record[] memory);\\n}\\n\",\"keccak256\":\"0xd6f2e609c42fed3def6cde7e2d14623e1252356ab0ce79db7fc491c302c491b2\",\"license\":\"MIT\"},\"contracts/core/interfaces/market/IMarketLiquidate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title IMarketLiquidate\\n * @dev Interface for liquidating and claiming positions in a market.\\n */\\ninterface IMarketLiquidate {\\n    /**\\n     * @dev Checks if a position is eligible for liquidation.\\n     * @param positionId The ID of the position to check.\\n     * @return A boolean indicating if the position is eligible for liquidation.\\n     */\\n    function checkLiquidation(uint256 positionId) external view returns (bool);\\n\\n    /**\\n     * @dev Liquidates a position.\\n     * @param positionId The ID of the position to liquidate.\\n     * @param keeper The address of the keeper performing the liquidation.\\n     * @param keeperFee The native token amount of the keeper's fee.\\n     */\\n    function liquidate(uint256 positionId, address keeper, uint256 keeperFee) external;\\n\\n    /**\\n     * @dev Checks if a position is eligible for claim.\\n     * @param positionId The ID of the position to check.\\n     * @return A boolean indicating if the position is eligible for claim.\\n     */\\n    function checkClaimPosition(uint256 positionId) external view returns (bool);\\n\\n    /**\\n     * @dev Claims a closed position on behalf of a keeper.\\n     * @param positionId The ID of the position to claim.\\n     * @param keeper The address of the keeper claiming the position.\\n     * @param keeperFee The native token amount of the keeper's fee.\\n     */\\n    function claimPosition(uint256 positionId, address keeper, uint256 keeperFee) external;\\n}\\n\",\"keccak256\":\"0xb17fe013f0b218ba61bff6a45be2b53326be747427e3f886f95806eaa9f4c8f4\",\"license\":\"MIT\"},\"contracts/core/libraries/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nuint256 constant BPS = 10000;\\nuint256 constant FEE_RATES_LENGTH = 36;\\n\",\"keccak256\":\"0x7090514076115048f25329d3a18a07456d07e1630c7e3ad13df01cb9f89e59de\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\n\\nlibrary Errors {\\n    string constant ONLY_DAO_CAN_ACCESS = \\\"DAO\\\";\\n    string constant ONLY_VAULT_CAN_ACCESS = \\\"VLT\\\";\\n    string constant ONLY_DEDICATED_MSG_SENDER_CAN_ACCESS = \\\"DMS\\\";\\n    string constant ONLY_LIQUIDATOR_CAN_ACCESS = \\\"LIQ\\\";\\n    string constant ONLY_FUNDS_OWNER_CAN_WITHDRAW_FUNDS = \\\"FOW\\\";\\n    string constant ETH_TRANSFER_FAILED = \\\"ETF\\\";\\n    string constant INVALID_SWAP_VALUE = \\\"ISV\\\";\\n    string constant NOT_ENOUGH_FREE_LIQUIDITY = \\\"NEFL\\\";\\n    string constant TOO_SMALL_AMOUNT = \\\"TSA\\\";\\n    string constant INVALID_ORACLE_VERSION = \\\"IOV\\\";\\n    string constant EXCEED_MARGIN_RANGE = \\\"IOV\\\";\\n    string constant UNSUPPORTED_TRADING_FEE_RATE = \\\"UTFR\\\";\\n    string constant ALREADY_REGISTERED_ORACLE_PROVIDER = \\\"ARO\\\";\\n    string constant ALREADY_REGISTERED_TOKEN = \\\"ART\\\";\\n    string constant UNREGISTERED_TOKEN = \\\"URT\\\";\\n    string constant INTEREST_RATE_NOT_INITIALIZED = \\\"IRNI\\\";\\n    string constant INTEREST_RATE_OVERFLOW = \\\"IROF\\\";\\n    string constant INTEREST_RATE_PAST_TIMESTAMP = \\\"IRPT\\\";\\n    string constant INTEREST_RATE_NOT_APPENDABLE = \\\"IRNA\\\";\\n    string constant INTEREST_RATE_ALREADY_APPLIED = \\\"IRAA\\\";\\n    string constant UNSETTLED_POSITION = \\\"USP\\\";\\n    string constant INVALID_POSITION_QTY = \\\"IPQ\\\";\\n}\\n\",\"keccak256\":\"0x42f8a4ee21e7d9a19a21dd1cad50631fe43f7d07bf56886be52413b6b55b7525\",\"license\":\"BUSL-1.1\"},\"contracts/core/libraries/InterestRate.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0 <0.9.0;\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {BPS} from \\\"@chromatic-protocol/contracts/core/libraries/Constants.sol\\\";\\nimport {Errors} from \\\"@chromatic-protocol/contracts/core/libraries/Errors.sol\\\";\\n\\n/**\\n * @title InterestRate\\n * @notice Provides functions for managing interest rates.\\n * @dev The library allows for the initialization, appending, and removal of interest rate records,\\n *      as well as calculating interest based on these records.\\n */\\nlibrary InterestRate {\\n    using Math for uint256;\\n\\n    /// @dev Record type\\n    struct Record {\\n        /// @dev Annual interest rate in BPS\\n        uint256 annualRateBPS;\\n        /// @dev Timestamp when the interest rate becomes effective\\n        uint256 beginTimestamp;\\n    }\\n\\n    uint256 private constant MAX_RATE_BPS = BPS; // max interest rate is 100%\\n    uint256 private constant YEAR = 365 * 24 * 3600;\\n\\n    /**\\n     * @dev Ensure that the interest rate records have been initialized before certain functions can be called.\\n     *      It checks whether the length of the Record array is greater than 0.\\n     */\\n    modifier initialized(Record[] storage self) {\\n        require(self.length > 0, Errors.INTEREST_RATE_NOT_INITIALIZED);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initialize the interest rate records.\\n     * @param self The stored record array\\n     * @param initialInterestRate The initial interest rate\\n     */\\n    function initialize(Record[] storage self, uint256 initialInterestRate) internal {\\n        self.push(Record({annualRateBPS: initialInterestRate, beginTimestamp: 0}));\\n    }\\n\\n    /**\\n     * @notice Add a new interest rate record to the array.\\n     * @dev Annual rate is not greater than the maximum rate and that the begin timestamp is in the future,\\n     *      and the new record's begin timestamp is greater than the previous record's timestamp.\\n     * @param self The stored record array\\n     * @param annualRateBPS The annual interest rate in BPS\\n     * @param beginTimestamp Begin timestamp of this record\\n     */\\n    function appendRecord(\\n        Record[] storage self,\\n        uint256 annualRateBPS,\\n        uint256 beginTimestamp\\n    ) internal initialized(self) {\\n        require(annualRateBPS <= MAX_RATE_BPS, Errors.INTEREST_RATE_OVERFLOW);\\n        require(beginTimestamp > block.timestamp, Errors.INTEREST_RATE_PAST_TIMESTAMP);\\n\\n        Record memory lastRecord = self[self.length - 1];\\n        require(beginTimestamp > lastRecord.beginTimestamp, Errors.INTEREST_RATE_NOT_APPENDABLE);\\n\\n        self.push(Record({annualRateBPS: annualRateBPS, beginTimestamp: beginTimestamp}));\\n    }\\n\\n    /**\\n     * @notice Remove the last interest rate record from the array.\\n     * @dev The current time must be less than the begin timestamp of the last record.\\n     *      If the array has only one record, it returns false along with an empty record.\\n     *      Otherwise, it removes the last record from the array and returns true along with the removed record.\\n     * @param self The stored record array\\n     * @return removed Whether the last record is removed\\n     * @return record The removed record\\n     */\\n    function removeLastRecord(\\n        Record[] storage self\\n    ) internal initialized(self) returns (bool removed, Record memory record) {\\n        if (self.length <= 1) {\\n            // empty\\n            return (false, Record(0, 0));\\n        }\\n\\n        Record memory lastRecord = self[self.length - 1];\\n        require(block.timestamp < lastRecord.beginTimestamp, Errors.INTEREST_RATE_ALREADY_APPLIED);\\n\\n        self.pop();\\n\\n        return (true, lastRecord);\\n    }\\n\\n    /**\\n     * @notice Find the interest rate record that applies to a given timestamp.\\n     * @dev It iterates through the array from the end to the beginning\\n     *      and returns the first record with a begin timestamp less than or equal to the provided timestamp.\\n     * @param self The stored record array\\n     * @param timestamp Given timestamp\\n     * @return interestRate The record which is found\\n     * @return index The index of record\\n     */\\n    function findRecordAt(\\n        Record[] storage self,\\n        uint256 timestamp\\n    ) internal view initialized(self) returns (Record memory interestRate, uint256 index) {\\n        for (uint256 i = self.length; i > 0; i--) {\\n            index = i - 1;\\n            interestRate = self[index];\\n\\n            if (interestRate.beginTimestamp <= timestamp) {\\n                return (interestRate, index);\\n            }\\n        }\\n\\n        return (self[0], 0); // empty result (this line is not reachable)\\n    }\\n\\n    /**\\n     * @notice Calculate the interest\\n     * @param self The stored record array\\n     * @param amount Token amount\\n     * @param from Begin timestamp (inclusive)\\n     * @param to End timestamp (exclusive)\\n     */\\n    function calculateInterest(\\n        Record[] storage self,\\n        uint256 amount,\\n        uint256 from, // timestamp (inclusive)\\n        uint256 to // timestamp (exclusive)\\n    ) internal view initialized(self) returns (uint256) {\\n        if (from >= to) {\\n            return 0;\\n        }\\n\\n        uint256 interest = 0;\\n\\n        uint256 endTimestamp = type(uint256).max;\\n        for (uint256 idx = self.length; idx > 0; idx--) {\\n            Record memory record = self[idx - 1];\\n            if (endTimestamp <= from) {\\n                break;\\n            }\\n\\n            interest += _interest(\\n                amount,\\n                record.annualRateBPS,\\n                Math.min(to, endTimestamp) - Math.max(from, record.beginTimestamp)\\n            );\\n            endTimestamp = record.beginTimestamp;\\n        }\\n        return interest;\\n    }\\n\\n    function _interest(\\n        uint256 amount,\\n        uint256 rateBPS, // annual rate\\n        uint256 period // in seconds\\n    ) private pure returns (uint256) {\\n        return amount.mulDiv(rateBPS * period, BPS * YEAR, Math.Rounding.Up);\\n    }\\n}\\n\",\"keccak256\":\"0x1f6bd79aefc6a5ac831cc3156d22761b99df09c73c37d200ee8972f3d7813f22\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60e06040523480156200001157600080fd5b50604051620012183803806200121883398101604081905262000034916200018e565b600080546001600160a01b0319166001600160a01b0385811691909117909155821660808190526040805163573ea57560e01b8152905184923092859263573ea575916004808201926020929091908290030181865afa1580156200009d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000c39190620001e2565b6001600160a01b0390811660c0528116620000ef575073c815db16d4be6ddf2685c201937905abf338f5d75b6040516337b6269f60e21b81526001600160a01b03838116600483015282169063ded89a7c906024016040805180830381865afa15801562000135573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200015b919062000209565b506001600160a01b031660a052506200024c945050505050565b6001600160a01b03811681146200018b57600080fd5b50565b600080600060608486031215620001a457600080fd5b8351620001b18162000175565b6020850151909350620001c48162000175565b6040850151909250620001d78162000175565b809150509250925092565b600060208284031215620001f557600080fd5b8151620002028162000175565b9392505050565b600080604083850312156200021d57600080fd5b82516200022a8162000175565b602084015190925080151581146200024157600080fd5b809150509250929050565b60805160a05160c051610f8562000293600039600050506000818160fa015281816105cd015261065701526000818160a801528181610aaf0152610c340152610f856000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80637bd5d063116100665780637bd5d063146101505780638e2cdf681461016357806396f823b414610176578063bcbaf48714610189578063e9fcf1f61461019c57600080fd5b8063049aacfe146100a3578063139f34cf146100e057806328f150eb146100f55780633011e5d41461011c578063373fa7601461013d575b600080fd5b6100ca7f000000000000000000000000000000000000000000000000000000000000000081565b6040516100d79190610c56565b60405180910390f35b6100f36100ee366004610c6a565b6101af565b005b6100ca7f000000000000000000000000000000000000000000000000000000000000000081565b61012f61012a366004610c98565b61024b565b6040516100d7929190610d0a565b6100f361014b366004610c6a565b610334565b61012f61015e366004610c98565b6103d6565b6100f3610171366004610c6a565b61046e565b6100f3610184366004610c6a565b61050f565b6100f3610197366004610c98565b6105a8565b6100f36101aa366004610c98565b610632565b60005460405163252c724f60e11b81526001600160a01b0390911690634a58e49e906101df903390600401610c56565b602060405180830381865afa1580156101fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102209190610d2d565b61023d57604051631353f3f160e01b815260040160405180910390fd5b6102486002826106ae565b50565b60405163627c32d960e11b8152600481018290526000906060906001600160a01b0385169063c4f865b290602401602060405180830381865afa158015610296573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ba9190610d2d565b15610319576001306001600160a01b031663e9fcf1f686866040516024016102e3929190610d56565b604051602081830303815290604052915060e01b6020820180516001600160e01b0383818316178352505050509150915061032d565b505060408051602081019091526000808252905b9250929050565b60005460405163252c724f60e11b81526001600160a01b0390911690634a58e49e90610364903390600401610c56565b602060405180830381865afa158015610381573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a59190610d2d565b6103c257604051631353f3f160e01b815260040160405180910390fd5b61024860028230633011e5d461025861075d565b60405163b86f6aef60e01b8152600481018290526000906060906001600160a01b0385169063b86f6aef90602401602060405180830381865afa158015610421573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104459190610d2d565b15610319576001306001600160a01b031663bcbaf48786866040516024016102e3929190610d56565b60005460405163252c724f60e11b81526001600160a01b0390911690634a58e49e9061049e903390600401610c56565b602060405180830381865afa1580156104bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104df9190610d2d565b6104fc57604051631353f3f160e01b815260040160405180910390fd5b61024860018230637bd5d063601e61075d565b60005460405163252c724f60e11b81526001600160a01b0390911690634a58e49e9061053f903390600401610c56565b602060405180830381865afa15801561055c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105809190610d2d565b61059d57604051631353f3f160e01b815260040160405180910390fd5b6102486001826106ae565b604080518082019091526003815262444d5360e81b6020820152336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106145760405162461bcd60e51b815260040161060b9190610d6f565b60405180910390fd5b50600061061f610aaa565b50905061062d838383610b37565b505050565b604080518082019091526003815262444d5360e81b6020820152336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106955760405162461bcd60e51b815260040161060b9190610d6f565b5060006106a0610aaa565b50905061062d838383610c1d565b336000818152602084815260408083208584529091529020548015610757576106d5610c32565b6001600160a01b031663ee8ca3b5826040518263ffffffff1660e01b815260040161070291815260200190565b600060405180830381600087803b15801561071c57600080fd5b505af1158015610730573d6000803e3d6000fd5b5050506001600160a01b038316600090815260208681526040808320878452909152812055505b50505050565b33600081815260208781526040808320888452909152902054156107815750610aa3565b60408051600381830181815260c083019093526000928291606080840190803683370190505081526040805160038082526080820190925260209092019190816020015b60608152602001906001900390816107c557505090528051805191925060009182906107f3576107f3610d82565b6020026020010190600381111561080c5761080c610d98565b9081600381111561081f5761081f610d98565b815250506001816000015160018151811061083c5761083c610d82565b6020026020010190600381111561085557610855610d98565b9081600381111561086857610868610d98565b815250506002816000015160028151811061088557610885610d82565b6020026020010190600381111561089e5761089e610d98565b908160038111156108b1576108b1610d98565b8152505030858584896040516024016108cb929190610d56565b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050604051602001610909929190610dae565b604051602081830303815290604052816020015160008151811061092f5761092f610d82565b602002602001018190525042836040516020016109629291906001600160801b0392831681529116602082015260400190565b604051602081830303815290604052816020015160018151811061098857610988610d82565b60200260200101819052506040518060200160405280600081525081602001516002815181106109ba576109ba610d82565b60200260200101819052506109cd610c32565b6040805163bcbaf48760e01b60208201526001600160a01b039290921691633323b467913091016040516020818303038152906040528473eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee6040518563ffffffff1660e01b8152600401610a389493929190610e27565b6020604051808303816000875af1158015610a57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7b9190610ee9565b6001600160a01b03909216600090815260208881526040808320898452909152902091909155505b5050505050565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b810c6366040518163ffffffff1660e01b81526004016040805180830381865afa158015610b0a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b2e9190610f02565b90939092509050565b826001600160a01b0381166379bd1eac84610b50610c32565b6001600160a01b031663573ea5756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb19190610f32565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b0316602482015260448101859052606401600060405180830381600087803b158015610bff57600080fd5b505af1158015610c13573d6000803e3d6000fd5b5050505050505050565b826001600160a01b03811663de7c8cc284610b505b7f000000000000000000000000000000000000000000000000000000000000000090565b6001600160a01b0391909116815260200190565b600060208284031215610c7c57600080fd5b5035919050565b6001600160a01b038116811461024857600080fd5b60008060408385031215610cab57600080fd5b8235610cb681610c83565b946020939093013593505050565b6000815180845260005b81811015610cea57602081850181015186830182015201610cce565b506000602082860101526020601f19601f83011685010191505092915050565b8215158152604060208201526000610d256040830184610cc4565b949350505050565b600060208284031215610d3f57600080fd5b81518015158114610d4f57600080fd5b9392505050565b6001600160a01b03929092168252602082015260400190565b602081526000610d4f6020830184610cc4565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b6001600160a01b0383168152604060208201819052600090610d2590830184610cc4565b600081518084526020808501808196508360051b8101915082860160005b85811015610e1a578284038952610e08848351610cc4565b98850198935090840190600101610df0565b5091979650505050505050565b6001600160a01b038516815260806020808301829052600091610e4c90840187610cc4565b838103604080860191909152865181835280519183018290528301906000906060840190825b81811015610eab5784516004808210610e9857634e487b7160e01b865260218152602486fd5b5083529386019391860191600101610e72565b505084890151925083810385850152610ec48184610dd2565b95505050505050610ee060608301846001600160a01b03169052565b95945050505050565b600060208284031215610efb57600080fd5b5051919050565b60008060408385031215610f1557600080fd5b825191506020830151610f2781610c83565b809150509250929050565b600060208284031215610f4457600080fd5b8151610d4f81610c8356fea2646970667358221220f8b9a4f44f33eb36e66334489bbe62ebf0dd25d08d5a14bc8386685709d440d064736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c80637bd5d063116100665780637bd5d063146101505780638e2cdf681461016357806396f823b414610176578063bcbaf48714610189578063e9fcf1f61461019c57600080fd5b8063049aacfe146100a3578063139f34cf146100e057806328f150eb146100f55780633011e5d41461011c578063373fa7601461013d575b600080fd5b6100ca7f000000000000000000000000000000000000000000000000000000000000000081565b6040516100d79190610c56565b60405180910390f35b6100f36100ee366004610c6a565b6101af565b005b6100ca7f000000000000000000000000000000000000000000000000000000000000000081565b61012f61012a366004610c98565b61024b565b6040516100d7929190610d0a565b6100f361014b366004610c6a565b610334565b61012f61015e366004610c98565b6103d6565b6100f3610171366004610c6a565b61046e565b6100f3610184366004610c6a565b61050f565b6100f3610197366004610c98565b6105a8565b6100f36101aa366004610c98565b610632565b60005460405163252c724f60e11b81526001600160a01b0390911690634a58e49e906101df903390600401610c56565b602060405180830381865afa1580156101fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102209190610d2d565b61023d57604051631353f3f160e01b815260040160405180910390fd5b6102486002826106ae565b50565b60405163627c32d960e11b8152600481018290526000906060906001600160a01b0385169063c4f865b290602401602060405180830381865afa158015610296573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ba9190610d2d565b15610319576001306001600160a01b031663e9fcf1f686866040516024016102e3929190610d56565b604051602081830303815290604052915060e01b6020820180516001600160e01b0383818316178352505050509150915061032d565b505060408051602081019091526000808252905b9250929050565b60005460405163252c724f60e11b81526001600160a01b0390911690634a58e49e90610364903390600401610c56565b602060405180830381865afa158015610381573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a59190610d2d565b6103c257604051631353f3f160e01b815260040160405180910390fd5b61024860028230633011e5d461025861075d565b60405163b86f6aef60e01b8152600481018290526000906060906001600160a01b0385169063b86f6aef90602401602060405180830381865afa158015610421573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104459190610d2d565b15610319576001306001600160a01b031663bcbaf48786866040516024016102e3929190610d56565b60005460405163252c724f60e11b81526001600160a01b0390911690634a58e49e9061049e903390600401610c56565b602060405180830381865afa1580156104bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104df9190610d2d565b6104fc57604051631353f3f160e01b815260040160405180910390fd5b61024860018230637bd5d063601e61075d565b60005460405163252c724f60e11b81526001600160a01b0390911690634a58e49e9061053f903390600401610c56565b602060405180830381865afa15801561055c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105809190610d2d565b61059d57604051631353f3f160e01b815260040160405180910390fd5b6102486001826106ae565b604080518082019091526003815262444d5360e81b6020820152336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106145760405162461bcd60e51b815260040161060b9190610d6f565b60405180910390fd5b50600061061f610aaa565b50905061062d838383610b37565b505050565b604080518082019091526003815262444d5360e81b6020820152336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106955760405162461bcd60e51b815260040161060b9190610d6f565b5060006106a0610aaa565b50905061062d838383610c1d565b336000818152602084815260408083208584529091529020548015610757576106d5610c32565b6001600160a01b031663ee8ca3b5826040518263ffffffff1660e01b815260040161070291815260200190565b600060405180830381600087803b15801561071c57600080fd5b505af1158015610730573d6000803e3d6000fd5b5050506001600160a01b038316600090815260208681526040808320878452909152812055505b50505050565b33600081815260208781526040808320888452909152902054156107815750610aa3565b60408051600381830181815260c083019093526000928291606080840190803683370190505081526040805160038082526080820190925260209092019190816020015b60608152602001906001900390816107c557505090528051805191925060009182906107f3576107f3610d82565b6020026020010190600381111561080c5761080c610d98565b9081600381111561081f5761081f610d98565b815250506001816000015160018151811061083c5761083c610d82565b6020026020010190600381111561085557610855610d98565b9081600381111561086857610868610d98565b815250506002816000015160028151811061088557610885610d82565b6020026020010190600381111561089e5761089e610d98565b908160038111156108b1576108b1610d98565b8152505030858584896040516024016108cb929190610d56565b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050604051602001610909929190610dae565b604051602081830303815290604052816020015160008151811061092f5761092f610d82565b602002602001018190525042836040516020016109629291906001600160801b0392831681529116602082015260400190565b604051602081830303815290604052816020015160018151811061098857610988610d82565b60200260200101819052506040518060200160405280600081525081602001516002815181106109ba576109ba610d82565b60200260200101819052506109cd610c32565b6040805163bcbaf48760e01b60208201526001600160a01b039290921691633323b467913091016040516020818303038152906040528473eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee6040518563ffffffff1660e01b8152600401610a389493929190610e27565b6020604051808303816000875af1158015610a57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7b9190610ee9565b6001600160a01b03909216600090815260208881526040808320898452909152902091909155505b5050505050565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b810c6366040518163ffffffff1660e01b81526004016040805180830381865afa158015610b0a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b2e9190610f02565b90939092509050565b826001600160a01b0381166379bd1eac84610b50610c32565b6001600160a01b031663573ea5756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb19190610f32565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b0316602482015260448101859052606401600060405180830381600087803b158015610bff57600080fd5b505af1158015610c13573d6000803e3d6000fd5b5050505050505050565b826001600160a01b03811663de7c8cc284610b505b7f000000000000000000000000000000000000000000000000000000000000000090565b6001600160a01b0391909116815260200190565b600060208284031215610c7c57600080fd5b5035919050565b6001600160a01b038116811461024857600080fd5b60008060408385031215610cab57600080fd5b8235610cb681610c83565b946020939093013593505050565b6000815180845260005b81811015610cea57602081850181015186830182015201610cce565b506000602082860101526020601f19601f83011685010191505092915050565b8215158152604060208201526000610d256040830184610cc4565b949350505050565b600060208284031215610d3f57600080fd5b81518015158114610d4f57600080fd5b9392505050565b6001600160a01b03929092168252602082015260400190565b602081526000610d4f6020830184610cc4565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b6001600160a01b0383168152604060208201819052600090610d2590830184610cc4565b600081518084526020808501808196508360051b8101915082860160005b85811015610e1a578284038952610e08848351610cc4565b98850198935090840190600101610df0565b5091979650505050505050565b6001600160a01b038516815260806020808301829052600091610e4c90840187610cc4565b838103604080860191909152865181835280519183018290528301906000906060840190825b81811015610eab5784516004808210610e9857634e487b7160e01b865260218152602486fd5b5083529386019391860191600101610e72565b505084890151925083810385850152610ec48184610dd2565b95505050505050610ee060608301846001600160a01b03169052565b95945050505050565b600060208284031215610efb57600080fd5b5051919050565b60008060408385031215610f1557600080fd5b825191506020830151610f2781610c83565b809150509250929050565b600060208284031215610f4457600080fd5b8151610d4f81610c8356fea2646970667358221220f8b9a4f44f33eb36e66334489bbe62ebf0dd25d08d5a14bc8386685709d440d064736f6c63430008130033",
  "devdoc": {
    "details": "A contract that handles the liquidation and claiming of positions in Chromatic markets.      It extends the Liquidator and AutomateReady contracts and implements the IChromaticLiquidator interface.",
    "errors": {
      "OnlyAccessableByMarket()": [
        {
          "details": "Throws an error indicating that the function can only be accessed by a registered market."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "cancelClaimPositionTask(uint256)": {
        "details": "Can only be called by a registered market.",
        "params": {
          "positionId": "The ID of the position for which to cancel the claim position task."
        }
      },
      "cancelLiquidationTask(uint256)": {
        "details": "Can only be called by a registered market.",
        "params": {
          "positionId": "The ID of the position for which to cancel the liquidation task."
        }
      },
      "claimPosition(address,uint256)": {
        "details": "Can only be called by the dedicated message sender.",
        "params": {
          "market": "The address of the market contract.",
          "positionId": "The ID of the position to be claimed."
        }
      },
      "constructor": {
        "details": "Constructor function.",
        "params": {
          "_automate": "The address of the Gelato Automate contract.",
          "_factory": "The address of the Chromatic Market Factory contract.",
          "opsProxyFactory": "The address of the Ops Proxy Factory contract."
        }
      },
      "createClaimPositionTask(uint256)": {
        "details": "Can only be called by a registered market.",
        "params": {
          "positionId": "The ID of the position to be claimed."
        }
      },
      "createLiquidationTask(uint256)": {
        "details": "Can only be called by a registered market.",
        "params": {
          "positionId": "The ID of the position to be liquidated."
        }
      },
      "liquidate(address,uint256)": {
        "details": "Can only be called by the dedicated message sender.",
        "params": {
          "market": "The address of the market contract.",
          "positionId": "The ID of the position to be liquidated."
        }
      },
      "resolveClaimPosition(address,uint256)": {
        "details": "This function is called by the Gelato automation system.",
        "params": {
          "market": "The address of the market contract.",
          "positionId": "The ID of the position to be claimed."
        },
        "returns": {
          "canExec": "Whether the claim can be executed.",
          "execPayload": "The encoded function call to execute the claim."
        }
      },
      "resolveLiquidation(address,uint256)": {
        "details": "This function is called by the Gelato automation system.",
        "params": {
          "market": "The address of the market contract.",
          "positionId": "The ID of the position to be liquidated."
        },
        "returns": {
          "canExec": "Whether the liquidation can be executed.",
          "execPayload": "The encoded function call to execute the liquidation."
        }
      }
    },
    "title": "ChromaticLiquidator",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "cancelClaimPositionTask(uint256)": {
        "notice": "Cancels a claim position task for a given position."
      },
      "cancelLiquidationTask(uint256)": {
        "notice": "Cancels a liquidation task for a given position."
      },
      "claimPosition(address,uint256)": {
        "notice": "Claims a position in a market."
      },
      "createClaimPositionTask(uint256)": {
        "notice": "Creates a claim position task for a given position."
      },
      "createLiquidationTask(uint256)": {
        "notice": "Creates a liquidation task for a given position."
      },
      "liquidate(address,uint256)": {
        "notice": "Liquidates a position in a market."
      },
      "resolveClaimPosition(address,uint256)": {
        "notice": "Resolves the claim of a position."
      },
      "resolveLiquidation(address,uint256)": {
        "notice": "Resolves the liquidation of a position."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 15734,
        "contract": "contracts/core/ChromaticLiquidator.sol:ChromaticLiquidator",
        "label": "factory",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IChromaticMarketFactory)25118"
      },
      {
        "astId": 15740,
        "contract": "contracts/core/ChromaticLiquidator.sol:ChromaticLiquidator",
        "label": "_liquidationTaskIds",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_bytes32))"
      },
      {
        "astId": 15746,
        "contract": "contracts/core/ChromaticLiquidator.sol:ChromaticLiquidator",
        "label": "_claimPositionTaskIds",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_bytes32))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IChromaticMarketFactory)25118": {
        "encoding": "inplace",
        "label": "contract IChromaticMarketFactory",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_bytes32))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => bytes32))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bytes32)"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}